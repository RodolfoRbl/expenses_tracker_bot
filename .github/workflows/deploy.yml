name: Deploy to AWS Lambda

on:
  push:
    branches:
      - dev

env:
  AWS_REGION: eu-central-1
  FUNCTION_NAME: ai_expenses_bot_v2
  LAYER_NAME: telegram-bot-layer
  TIMEOUT: 10
  MEMORY_SIZE: 384

jobs:
  build-layer:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check if Lambda Layer exists
        id: check_layer
        run: |
          layer_exists=$(aws lambda list-layer-versions --layer-name telegram-bot-layer --query "LayerVersions[0].Version" --output text)
          if [ "$layer_exists" != "None" ]; then
            echo "Layer already exists. Skipping Docker build and deployment."
            echo "exists=true" >> $GITHUB_ENV
          else
            echo "Layer does not exist. Proceeding with Docker build and upload."
            echo "exists=false" >> $GITHUB_ENV
          fi

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for Lambda Layer
        if: env.exists == 'false'
        run: |
          docker build -t lambda-layer .

      - name: Run Docker Lambda Layer container
        if: env.exists == 'false'
        run: |
          docker run -d --name lambda-container lambda-layer tail -f /dev/null
          docker cp lambda-container:/mnt/my-layer.zip ./my-layer.zip &&
          docker stop lambda-container &&
          docker rm lambda-container
          mkdir -p layers
          mv ./my-layer.zip ./layers/my-layer.zip

      - name: Deploy Layer if not exists
        if: env.exists == 'false'
        run: |
          # Publish the layer
          LAYER_VERSION=$(aws lambda publish-layer-version \
          --layer-name ${{ env.LAYER_NAME }} \
          --zip-file fileb://layers/my-layer.zip \
          --compatible-runtimes python3.11 \
          --query 'Version' \
          --output text)

          # Build the full layer ARN
          LAYER_ARN="arn:aws:lambda:${{ env.AWS_REGION }}:${{ secrets.AWS_ACCOUNT_ID }}:layer:${{ env.LAYER_NAME }}:$LAYER_VERSION"

          # Attach layer to the function
          aws lambda update-function-configuration \
            --function-name ${{ env.FUNCTION_NAME }} \
            --layers $LAYER_ARN \
            --handler lambda_function.lambda_handler \
            --timeout ${{ env.TIMEOUT }} \
            --memory-size ${{ env.MEMORY_SIZE }} \
            --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/service-role/RRR_DynamoDBFullAccess

      # - name: Delete layer (Only for testing purposes)
      #   run: |
      #     EXISTING_LAYER_VERSION=$(aws lambda list-layer-versions \
      #     --layer-name ${{ env.LAYER_NAME }} \
      #     --query 'LayerVersions[0].Version' \
      #     --region ${{ env.AWS_REGION }} \
      #     --output text)
      #     echo "Existing Layer Version: $EXISTING_LAYER_VERSION"

      #     if [ "$EXISTING_LAYER_VERSION" != "None" ]; then
      #       echo "Deleting existing layer version..."
      #       aws lambda delete-layer-version \
      #         --layer-name ${{ env.LAYER_NAME }} \
      #         --version-number $EXISTING_LAYER_VERSION
      #     else
      #       echo "No existing layer to delete."
      #     fi

  deploy-code:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create deployment package
        run: |
          cd src
          zip -r ../deployment.zip . -x ".git/*" ".github/*" "__pycache__/*" "*.pyc"

      - name: Deploy to Lambda
        run: |
          aws lambda update-function-code \
            --function-name ${{ env.FUNCTION_NAME }} \
            --zip-file fileb://deployment.zip
